<!--

     3jsbot code stencil
     Implementation of robot kinematics, control, and decision making 
     in HTML5/JavaScript and threejs
     
     @author odestcj / https://github.com/odestcj

     Forgive my coding style.  I am still a typedef struct kind of guy.
     Need to get a handle on all of the global variables... in the future.
-->

<html>
<head>
	<!-- //////////////////////////////////////////////////
     /////     JAVASCRIPT INCLUDES
     ////////////////////////////////////////////////// -->
	
	<!-- threejs - https://github.com/mrdoob/three.js/ - for 3D rendering -->
	<script src="js/three.min.js"></script>
	
	<!-- threejs camera controls helpers -->
	<script src="js/TrackballControls.js"></script>
	<script src="js/OrbitControls.js"></script>
	
	<!-- threejs keyboard input helper -->
	<script src="js/THREEx.KeyboardState.js"></script>
	
	<!-- numericjs - https://github.com/sloisel/numeric - for matrix inversion -->
	<script src="js/numeric-1.2.6.js"></script>
	
	<!-- definition of robot kinematics -->
	<!-- CS148: change this script pointer to change the robot definition -->
	<!--
	<script src="robots/robot_urdf_example.js"></script> 
	<script src="robots/robot_crawler.js"></script> 
	-->
	<script src="robots/robot_br2.js"></script> 
	 
	<!-- 3jsbot includes -->
	<script src="3jsbot.js"></script> 
	<!--
	<script src="3jsbot_forward_kinematics.js"></script> 
	<script src="3jsbot_controls.js"></script> 
	<script src="3jsbot_pd_control.js"></script> 
	<script src="3jsbot_inverse_kinematics.js"></script> 
	<script src="3jsbot_potential_field.js"></script> 
	<script src="3jsbot_rrt_connect.js"></script> 
	<script src="3jsbot_matrix.js"></script> 
	<script src="3jsbot_quaternion.js"></script> 
	-->
	<script src="3jsbot_threejs.js"></script> 
	<script src="3jsbot_userinput.js"></script>
	<link rel="stylesheet" href="style.css" title="3jsbot CSS" type="text/css" media="screen" charset="utf-8">
		
</head>


<body>
<div id="wrapper">
	<div id="header">
		<h1>3jsBot</h1>
		<h2>z: jitter, x: up, c: down</h2>
	</div>
	<div id="main">
	<div id="working">
	 
	
	<script>
	
	//////////////////////////////////////////////////
	/////     MAIN FUNCTION CALLS
	//////////////////////////////////////////////////
	
	// 3jsbot uses init() to initialize threejs scene, user input, and robot kinematics
	// CS148: you should use my_init() instead
	init();
	
	// 3jsbot uses animate() as the main animation loop maintained by threejs 
	// CS148: you should use my_animate() instead
	animate();
	
	
	
	// CS148: my_animate is where your robot's controls and movement are updated over time
	function my_init() {
	
	    init_robot();  // initialize robot kinematics
	
	    // CS148: INITIAL GETTING FAMILIAR CODE  (START HERE)	
	    var local_spacing = 0.9;  // variables declared with "var" are local 
	    global_spacing = 0.9;  // variables declared with "var" are global
	
	    my_object = {};  // objects can be created with braces
	    my_object.university = "Brown";  // create object property with an assignment
	    my_object.course_number = 148;  
	    my_object["subject"] = "robotics";  
	    if (typeof copied_object === 'undefined') {  // if my_object does not already exist
	        console.log(my_object);  // check it out on the console  
	    }
	
	    // objects are copied by reference
	    copied_object = my_object;
	    copied_object.subject = "autonomous_robotics";  // what is my_object.subject on the console?
	    //ANSWER: the reference of copied_object to my_object has set the subject of my_object to autonomous_robots
	
	    my_array = [8, 6, 7, 5, 3, 0, 9]; 
	    my_array[6] = 'ni-i-i-ine';
	    var i;  // local variable
	    for (i=0;i<my_array.length;i++) {
	        console.log(my_array[i]);
	    }
	    
	    var workingDiv = document.getElementById("working");
		//Define a global flags for whether or not jitter is turned on, the direction of movement, and the net sum of movement registered thus far.
	    jitter = 1;
	    move = 0;
	    moveAmt=0;

	    textbar = document.createElement('div');
		textbar.id="textbar";
	    //textbar.style.zIndex = 1;    // if you still don't see the label, try uncommenting this
	    //textbar.style.width = window.innerWidth-10;
	    //textbar.style.height = 20;
	    //textbar.style.backgroundColor = "black";
	    //textbar.style.color = "#00ff00";
	    textbar.innerHTML = "Welcome to 3jsbot! This is the command log.";
	    //textbar.style.top = 10 + 'px';
	    //textbar.style.left = 10 + 'px';
	    
	    workingDiv.appendChild(textbar);
	
	    // CS148: INITIAL GETTING FAMILIAR CODE  (END HERE)
	
	}
	
	
	function init_robot() {
	        
	    // ASSUME: robot kinematics are described separate js file (eg., "robot_urdf_example.js")
	
	    // initialize and create threejs mesh objects for robot links
	    init_robot_links();
	
	    // initialize robot joints and create threejs mesh objects for robot joints and form kinematic hiearchy
	    init_robot_joints();
	
	    // initialize inverse kinematics target location 
	    ik_target = [[0],[0.8],[1.0],[1]];
	
	}
	
	// CS148: nothing to add here 
	function init_robot_links() {
	
	    for (x in robot.links) {
	        robot.links[x].name = x;
	    }
	
	    // CS148: do not remove, this is used to create threejs geometries
	    init_robot_links_geoms();
	
	    // initialize controls for robot base link
	    robot.control = {xyz: [0,0,0], rpy:[0,0,0]}; 
	}
	
	
	// CS148: add kinematic hierarchy in this function
	function init_robot_joints() {
	    // build kinematic hierarchy by looping over each joint in the robot
	    //   (object fields can be index through array-style indices, object[field] = property)
	    //   and insert threejs scene graph (each joint and link are directly connect to scene root)
	    // NOTE: kinematic hierarchy is maintained independently by this code, not threejs
	    // NOTE: simpleApplyMatrix can be used to set threejs transform for a rendered object
	
	    var x,tempmat;
	
	    for (x in robot.joints) {
	
	        // give the joint its name as an id
	        robot.joints[x].name = x;
	        console.log(robot.joints[x].child); // to print the child link of joints for example
	
	        // CONSTRUCT KINEMATIC HIERARCHY
	    }
	
	    // CS148: do not remove, this is used to create threejs geometries
	    init_robot_joints_geoms();
	}
	
	
	//This function is called from the stencil animate() function, instead of my_animate(). This function looks for key presses of interest, and then passes control along to my_animate() once key presses have been registered.
	function keypressDetect(){
		 // keyboard is threejs helper for reading keyboard state
	    if (keyboard.pressed("x")){
	        textbar.innerHTML = "moving up";  // make the pieces move up
	        move=1; //set the move flag to one.
	        my_animate();
	    }else if(keyboard.pressed("c")){
	    	textbar.innerHTML = "moving down";  // make the pieces move up
	        move=-1; //set the move flag to -one.
	        my_animate();
	    }else if (keyboard.pressed("z")){
	    	//If z is pressed on the keyboard pass my_animate as a callback along to the toggle_jitter() function to toggle the jitter flag
	        toggle(function(){
		        my_animate();
	        }, "z");	    
	    }else{
		    my_animate();
	    }
	}
	
	//Take as an argument the my_animate() function as a callback. This prevents the main loop from looping around on the user while they're pressing the key and thus triggering flip-flopping of states.
	//Toggle the state of the jitter var to the opposite of its current value after a timeout of 100 ms. If after the 100ms timeout, the state of the keypress has reversed, indicating a key-press, then flip states. Otherwise, loop again.
	function toggle(my_animate, key) {
		if (jitter === 1){
			setTimeout(function(){
				if(!keyboard.pressed(key)){
					textbar.innerHTML = "Jittering was turned off.";  // stop jittering the pieces
					jitter = 0;
				}
			}, 100);
		}else{
			setTimeout(function(){
				if(!keyboard.pressed(key)){
					textbar.innerHTML = "Jittering was turned on."; // start jittering the pieces
					jitter = 1;	
				}
			}, 100);	
		}
		my_animate();
	}
	
	
	
	
	//////////////////////////////////////////////////
	/////     ANIMATION AND INTERACTION LOOP
	//////////////////////////////////////////////////
	
	// CS148: my_animate is where your robot's controls and movement are updated over time
	function my_animate() {
	
	    // CS148: INITIAL GETTING FAMILIAR CODE  (START HERE)
	
	   
	
	    // jsmat will be used to transform a 3D object to a specific location in the world
	    // we will represent matrices with index notation 
	    //   such that matrix[row][column] is the indexing
	    var jsmat = [
	                [1, 0, 0, 0],
	                [0, 1, 0, 0],
	                [0, 0, 1, 0],
	                [0, 0, 0, 1] 
	    ];
	
	    var spacing = 0.9;  // variables declared with "var" are local 
	
	    // jsmat[0][3] corresponds to the x-coordinate of the position for the 3D object
	    // Object.key(object) is a rough way to get number of keys in an object
	    jsmat[0][3] = -Object.keys(robot.joints).length*spacing/2;  
		
		//Check if the move flag has been set. Set the move increment as appropriate
		if(move===1){
		   	moveAmt+=.1;
	    }else if(move===-1){
		   	moveAmt+=-.1;
	    }else{
		   	moveAmt+=0;
	    }
	    
	    //If the jitter flag is set to 1, transform the positions by a random offset and the move offset, if any.
		if(jitter===1){
		    // iterate over each joint of the robot independently
		    for (x in robot.joints) {
		
		        // jsmat[1][3] corresponds to the y-coordinate of the position for the 3D object
		        jsmat[1][3] = 2+moveAmt+Math.random()*0.02;  // Math object has lots of helpful functions
		
		        // jsmat[2][3] corresponds to the z-coordinate of the position for the 3D object
		        jsmat[2][3] = Math.random()*0.02;
		
		        // convert 2D JavaScript array to the threejs format
		        threemat = matrix_2Darray_to_threejs(jsmat); 
		
		        // transform 
		        simpleApplyMatrix(robot.joints[x].geom,threemat);
		
		        jsmat[0][3] += spacing;
		    } 
		
		    // iterate over each link of the robot independently
		    jsmat[0][3] = -Object.keys(robot.joints).length*spacing/2;
		    for (x in robot.links) {
		        jsmat[1][3] = 1+moveAmt+Math.random()*0.02;
		        jsmat[2][3] = Math.random()*0.02;
		        threemat = matrix_2Darray_to_threejs(jsmat);
		        simpleApplyMatrix(robot.links[x].geom,threemat);
		        jsmat[0][3] += spacing;
		    }
		//If the jitter flag isn't set, transform the positions only by the offset.
	    }else{		
	    	//moveAmt is a variable defining the net sum of up and down positions thus far. We transform the joints by 2 plus this value
			jsmat[1][3] += 2+moveAmt;
		    for(x in robot.joints){
				
		        // convert 2D JavaScript array to the threejs format
		        threemat = matrix_2Darray_to_threejs(jsmat); 
		
		        // transform 
		        simpleApplyMatrix(robot.joints[x].geom,threemat);
		
		        jsmat[0][3] += spacing;
		    }
		    //We transform the links by a value of 1 plus the net sum of vertical movement.
			jsmat[1][3] = 1+moveAmt;
		    jsmat[0][3] = -Object.keys(robot.joints).length*spacing/2;
		    for (x in robot.links) {
		        threemat = matrix_2Darray_to_threejs(jsmat);
		        simpleApplyMatrix(robot.links[x].geom,threemat);
		        jsmat[0][3] += spacing;
		    }
		}

	    
	    //Clear the move flag off. It will be reset to 1 on the next time through the loop if the appropriate key is still pressed.
	    move=0;
	
	
	    // CS148: INITIAL GETTING FAMILIAR CODE  (END)
	
	 
	    // ROBOT DYNAMICS 
	
	    // apply robot controls to robot configuration (assuming pure kinematics for now)
	    //robot_apply_controls();
	
	    // DRAW ROBOT 
	
	    // forward kinematics over robot links
	    //robot_forward_kinematics();
	
	    // HANDLE USER CONTROLS
	
	    // handle user input 
	    user_input();
	
	    // UPDATE AUTONOMOUS CONTROLS 
	
	    // proportional-derivative control 
	    /*
	    if (update_pd)
	        robot_pd_control();
	    update_pd = false;
	    */
	
	    // inverse kinematics
	    //robot_inverse_kinematics(ik_target, "forearm_right_yaw", ik_local);
	
	    // configuration space motion planning
	    //robot_rrt_connect(q_desired);
	
	    // Monte Carlo Localization (needs display map and simulated range sensing)
	    // if we have time this semester
	    //robot_potential_field(x_desired);
	
	    // potential field navigation (needs display_map for collisions)
	    // if we have time this semester
	    //robot_potential_field(x_desired);
	
	
	}
	
	
	
</script>
	</div>
	</div>


</div>
</body>
</html>

